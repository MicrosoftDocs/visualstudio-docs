---
title: Security Warnings
ms.date: 10/02/2019
ms.topic: reference
f1_keywords:
- vs.codeanalysis.securityrules
helpviewer_keywords:
- security [Visual Studio ALM], Enterprise Templates
- security warnings
- managed code analysis warnings, security warnings
- warnings, security
ms.assetid: 60d4e8ea-230a-494f-aa6a-b91db77540e4
author: mikejo5000
ms.author: mikejo
manager: jillfra
ms.workload:
- multiple
---
# Security warnings

Security warnings support safer libraries and applications. These warnings help prevent security flaws in your program. If you disable any of these warnings, you should clearly mark the reason in code and also inform the designated security officer for your development project.

## In this section

|Rule|Description|
|----------|-----------------|
|[CA2100: Review SQL queries for security vulnerabilities](../code-quality/ca2100.md)|A method sets the System.Data.IDbCommand.CommandText property by using a string that is built from a string argument to the method. This rule assumes that the string argument contains user input. A SQL command string built from user input is vulnerable to SQL injection attacks.|
|[CA2102: Catch non-CLSCompliant exceptions in general handlers](../code-quality/ca2102.md)|A member in an assembly that is not marked with the RuntimeCompatibilityAttribute or is marked RuntimeCompatibility(WrapNonExceptionThrows = false) contains a catch block that handles System.Exception and does not contain an immediately following general catch block.|
|[CA2103: Review imperative security](../code-quality/ca2103.md)|A method uses imperative security and might be constructing the permission by using state information or return values that can change while the demand is active. Use declarative security whenever possible.|
|[CA2104: Do not declare read only mutable reference types](../code-quality/ca2104.md)|An externally visible type contains an externally visible read-only field that is a mutable reference type. A mutable type is a type whose instance data can be modified.|
|[CA2105: Array fields should not be read only](../code-quality/ca2105.md)|When you apply the read-only (ReadOnly in Visual Basic) modifier to a field that contains an array, the field cannot be changed to reference a different array. However, the elements of the array stored in a read-only field can be changed.|
|[CA2106: Secure asserts](../code-quality/ca2106.md)|A method asserts a permission and no security checks are performed on the caller. Asserting a security permission without performing any security checks can leave an exploitable security weakness in your code.|
|[CA2107: Review deny and permit only usage](../code-quality/ca2107.md)|Using the PermitOnly method and CodeAccessPermission.Deny security actions should be used only by those with an advanced knowledge of .NET security. Code that uses these security actions should undergo a security review.|
|[CA2108: Review declarative security on value types](../code-quality/ca2108.md)|A public or protected value type is secured by Data Access or Link Demands.|
|[CA2109: Review visible event handlers](../code-quality/ca2109.md)|A public or protected event-handling method was detected. Event-handling methods should not be exposed unless absolutely necessary.|
|[CA2111: Pointers should not be visible](../code-quality/ca2111.md)|A pointer is not private, internal, or read-only. Malicious code can change the value of the pointer, potentially allowing access to arbitrary locations in memory or causing application or system failures.|
|[CA2112: Secured types should not expose fields](../code-quality/ca2112.md)|A public or protected type contains public fields and is secured by Link Demands. If code has access to an instance of a type that is secured by a link demand, the code does not have to satisfy the link demand to access the type's fields.|
|[CA2114: Method security should be a superset of type](../code-quality/ca2114.md)|A method should not have both method-level and type-level declarative security for the same action.|
|[CA2115: Call GC.KeepAlive when using native resources](../code-quality/ca2115.md)|This rule detects errors that might occur because an unmanaged resource is being finalized while it is still being used in unmanaged code.|
|[CA2116: APTCA methods should only call APTCA methods](../code-quality/ca2116.md)|When the APTCA (AllowPartiallyTrustedCallers) attribute is present on a fully trusted assembly, and the assembly executes code in another assembly that does not allow partially trusted callers, a security exploit is possible.|
|[CA2117: APTCA types should only extend APTCA base types](../code-quality/ca2117.md)|When the APTCA (AllowPartiallyTrustedCallers) attribute is present on a fully trusted assembly, and a type in the assembly inherits from a type that does not allow partially trusted callers, a security exploit is possible.|
|[CA2118: Review SuppressUnmanagedCodeSecurityAttribute usage](../code-quality/ca2118.md)|SuppressUnmanagedCodeSecurityAttribute changes the default security system behavior for members that execute unmanaged code that uses COM interop or platform invocation. This attribute is primarily used to increase performance; however, the performance gains come with significant security risks.|
|[CA2119: Seal methods that satisfy private interfaces](../code-quality/ca2119.md)|An inheritable public type provides an overridable method implementation of an internal (Friend in Visual Basic) interface. To fix a violation of this rule, prevent the method from being overridden outside the assembly.|
|[CA2120: Secure serialization constructors](../code-quality/ca2120.md)|This type has a constructor that takes a System.Runtime.Serialization.SerializationInfo object and a System.Runtime.Serialization.StreamingContext object (the signature of the serialization constructor). This constructor is not secured by a security check, but one or more of the regular constructors in the type are secured.|
|[CA2121: Static constructors should be private](../code-quality/ca2121.md)|The system calls the static constructor before the first instance of the type is created or any static members are referenced. If a static constructor is not private, it can be called by code other than the system. Depending on the operations that are performed in the constructor, this can cause unexpected behavior.|
|[CA2122: Do not indirectly expose methods with link demands](../code-quality/ca2122.md)|A public or protected member has Link Demands and is called by a member that does not perform any security checks. A link demand checks the permissions of the immediate caller only.|
|[CA2123: Override link demands should be identical to base](../code-quality/ca2123.md)|This rule matches a method to its base method, which is either an interface or a virtual method in another type, and then compares the link demands on each. If this rule is violated, a malicious caller can bypass the link demand just by calling the unsecured method.|
|[CA2124: Wrap vulnerable finally clauses in outer try](../code-quality/ca2124.md)|A public or protected method contains a try/finally block. The finally block appears to reset the security state and is not itself enclosed in a finally block.|
|[CA2126: Type link demands require inheritance demands](../code-quality/ca2126.md)|A public unsealed type is protected with a link demand and has an overridable method. Neither the type nor the method is protected with an inheritance demand.|
|[CA2130: Security critical constants should be transparent](../code-quality/ca2130.md)|Transparency enforcement is not enforced for constant values because compilers inline constant values so that no lookup is required at run time. Constant fields should be security transparent so that code reviewers do not assume that transparent code cannot access the constant.|
|[CA2131: Security critical types may not participate in type equivalence](../code-quality/ca2131.md)|A type participates in type equivalence and either the type itself, or a member or field of the type, is marked with the SecurityCriticalAttribute attribute. This rule fires on any critical types or types that contain critical methods or fields that are participating in type equivalence. When the CLR detects such a type, it fails to load it with a TypeLoadException at run time. Typically, this rule fires only when users implement type equivalence manually rather than by relying on tlbimp and the compilers to do the type equivalence.|
|[CA2132: Default constructors must be at least as critical as base type default constructors](../code-quality/ca2132.md)|Types and members that have the SecurityCriticalAttribute cannot be used by Silverlight application code. Security-critical types and members can be used only by trusted code in the .NET Framework for Silverlight class library. Because a public or protected construction in a derived class must have the same or greater transparency than its base class, a class in an application cannot be derived from a class marked SecurityCritical.|
|[CA2133: Delegates must bind to methods with consistent transparency](../code-quality/ca2133.md)|This warning fires on a method that binds a delegate that is marked with the SecurityCriticalAttribute to a method that is transparent or that is marked with the SecuritySafeCriticalAttribute. The warning also fires a method that binds a delegate that is transparent or safe-critical to a critical method.|
|[CA2134: Methods must keep consistent transparency when overriding base methods](../code-quality/ca2134.md)|This rule fires when a method marked with the SecurityCriticalAttribute overrides a method that is transparent or marked with the SecuritySafeCriticalAttribute. The rule also fires when a method that is transparent or marked with the SecuritySafeCriticalAttribute overrides a method that is marked with a SecurityCriticalAttribute. The rule is applied when overriding a virtual method or implementing an interface.|
|[CA2135: Level 2 assemblies should not contain LinkDemands](../code-quality/ca2135.md)|LinkDemands are deprecated in the level 2 security rule set. Instead of using LinkDemands to enforce security at just-in-time (JIT) compilation time, mark the methods, types, and fields with the SecurityCriticalAttribute attribute.|
|[CA2136: Members should not have conflicting transparency annotations](../code-quality/ca2136.md)|Transparency attributes are applied from code elements of larger scope to elements of smaller scope. The transparency attributes of code elements with larger scope take precedence over transparency attributes of code elements that are contained in the first element. For example, a class that is marked with the SecurityCriticalAttribute attribute cannot contain a method that is marked with the SecuritySafeCriticalAttribute attribute.|
|[CA2137: Transparent methods must contain only verifiable IL](../code-quality/ca2137.md)|A method contains unverifiable code or returns a type by reference. This rule fires on attempts by security transparent code to execute unverifiable MSIL (Microsoft Intermediate Language). However, the rule does not contain a full IL verifier, and instead uses heuristics to catch most violations of MSIL verification.|
|[CA2138: Transparent methods must not call methods with the SuppressUnmanagedCodeSecurity attribute](../code-quality/ca2138.md)|A security transparent method calls a method that is marked with the SuppressUnmanagedCodeSecurityAttribute attribute.|
|[CA2139: Transparent methods may not use the HandleProcessCorruptingExceptions attribute](../code-quality/ca2139.md)|This rule fires on any method that's transparent and attempts to handle a process corrupting exception by using the HandleProcessCorruptedStateExceptionsAttribute attribute. A process corrupting exception is a CLR version 4.0 exception classification of exceptions such as <xref:System.AccessViolationException>. The HandleProcessCorruptedStateExceptionsAttribute attribute may only be used by security critical methods, and will be ignored if it is applied to a transparent method.|
|[CA2140: Transparent code must not reference security critical items](../code-quality/ca2140.md)|Methods that are marked with SecurityTransparentAttribute call non-public members that are marked as SecurityCritical. This rule analyzes all methods and types in an assembly that is mixed transparent and critical, and flags any calls from transparent code to non-public critical code that are not marked SecurityTreatAsSafe.|
|[CA2141:Transparent methods must not satisfy LinkDemands](../code-quality/ca2141.md)|A security transparent method calls a method in an assembly that is not marked with the AllowPartiallyTrustedCallersAttribute (APTCA) attribute, or a security transparent method satisfies a LinkDemand for a type or a method.|
|[CA2142: Transparent code should not be protected with LinkDemands](../code-quality/ca2142.md)|This rule fires on transparent methods which require LinkDemands to access them. Security transparent code should not be responsible for verifying the security of an operation, and therefore should not demand permissions.|
|[CA2143: Transparent methods should not use security demands](../code-quality/ca2143.md)|Security transparent code should not be responsible for verifying the security of an operation, and therefore should not demand permissions. Security transparent code should use full demands to make security decisions and safe-critical code should not rely on transparent code to have made the full demand.|
|[CA2144: Transparent code should not load assemblies from byte arrays](../code-quality/ca2144.md)|The security review for transparent code is not as thorough as the security review for critical code, because transparent code cannot perform security sensitive actions. Assemblies loaded from a byte array might not be noticed in transparent code, and that byte array might contain critical, or more importantly safe-critical code, that does need to be audited.|
|[CA2145: Transparent methods should not be decorated with the SuppressUnmanagedCodeSecurityAttribute](../code-quality/ca2145.md)|Methods decorated with the SuppressUnmanagedCodeSecurityAttribute attribute have an implicit LinkDemand placed upon any method that calls it. This LinkDemand requires that the calling code be security critical. Marking the method that uses SuppressUnmanagedCodeSecurity with the SecurityCriticalAttribute attribute makes this requirement more obvious for callers of the method.|
|[CA2146: Types must be at least as critical as their base types and interfaces](../code-quality/ca2146.md)|This rule fires when a derived type has a security transparency attribute that is not as critical as its base type or implemented interface. Only critical types can derive from critical base types or implement critical interfaces, and only critical or safe-critical types can derive from safe-critical base types or implement safe-critical interfaces.|
|[CA2147: Transparent methods may not use security asserts](../code-quality/ca2147.md)|This rule analyzes all methods and types in an assembly that is either 100% transparent or mixed transparent/critical, and flags any declarative or imperative use of Assert.|
|[CA2149: Transparent methods must not call into native code](../code-quality/ca2149.md)|This rule fires on any transparent method that calls directly into native code, for example, through a P/Invoke. Violations of this rule lead to a MethodAccessException in the level 2 transparency model, and a full demand for UnmanagedCode in the level 1 transparency model.|
|[CA2151: Fields with critical types should be security critical](../code-quality/ca2151.md)|To use security critical types, the code that references the type must be either security critical or security safe critical. This is true even if the reference is indirect. Therefore, having a security transparent or security safe critical field is misleading because transparent code will still be unable to access the field.|
|[CA2153: Avoid Handling Corrupted State Exceptions](../code-quality/ca2153.md)|[Corrupted State Exceptions (CSE)](https://msdn.microsoft.com/magazine/dd419661.aspx) indicate that memory corruption exists in your process. Catching these rather than allowing the process to crash can lead to security vulnerabilities if an attacker can place an exploit into the corrupted memory region.|
|[CA2300: Do not use insecure deserializer BinaryFormatter](../code-quality/ca2300.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2301: Do not call BinaryFormatter.Deserialize without first setting BinaryFormatter.Binder](../code-quality/ca2301.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2302: Ensure BinaryFormatter.Binder is set before calling BinaryFormatter.Deserialize](../code-quality/ca2302.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2305: Do not use insecure deserializer LosFormatter](../code-quality/ca2305.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2310: Do not use insecure deserializer NetDataContractSerializer](../code-quality/ca2310.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2311: Do not deserialize without first setting NetDataContractSerializer.Binder](../code-quality/ca2311.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2312: Ensure NetDataContractSerializer.Binder is set before deserializing](../code-quality/ca2312.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2315: Do not use insecure deserializer ObjectStateFormatter](../code-quality/ca2315.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2321: Do not deserialize with JavaScriptSerializer using a SimpleTypeResolver](../code-quality/ca2321.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2322: Ensure JavaScriptSerializer is not initialized with SimpleTypeResolver before deserializing](../code-quality/ca2322.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2326: Do not use TypeNameHandling values other than None](../code-quality/ca2326.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2327: Do not use insecure JsonSerializerSettings](../code-quality/ca2327.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2328: Ensure that JsonSerializerSettings are secure](../code-quality/ca2328.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2329: Do not deserialize with JsonSerializer using an insecure configuration](../code-quality/ca2329.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA2330: Ensure that JsonSerializer has a secure configuration when deserializing](../code-quality/ca2330.md)|Insecure deserializers are vulnerable when deserializing untrusted data. An attacker could modify the serialized data to include unexpected types to inject objects with malicious side effects.|
|[CA3001: Review code for SQL injection vulnerabilities](../code-quality/ca3001.md)|When working with untrusted input and SQL commands, be mindful of SQL injection attacks. An SQL injection attack can execute malicious SQL commands, compromising the security and integrity of your application.|
|[CA3002: Review code for XSS vulnerabilities](../code-quality/ca3002.md)|When working with untrusted input from web requests, be mindful of cross-site scripting (XSS) attacks. An XSS attack injects untrusted input into raw HTML output, allowing the attacker to execute malicious scripts or maliciously modify content in your web page.|
|[CA3003: Review code for file path injection vulnerabilities](../code-quality/ca3003.md)|When working with untrusted input from web requests, be mindful of using user-controlled input when specifying paths to files.|
|[CA3004: Review code for information disclosure vulnerabilities](../code-quality/ca3004.md)|Disclosing exception information gives attackers insight into the internals of your application, which can help attackers find other vulnerabilities to exploit.|
|[CA3006: Review code for process command injection vulnerabilities](../code-quality/ca3006.md)|When working with untrusted input, be mindful of command injection attacks. A command injection attack can execute malicious commands on the underlying operating system, compromising the security and integrity of your server.|
|[CA3007: Review code for open redirect vulnerabilities](../code-quality/ca3007.md)|When working with untrusted input, be mindful of open redirect vulnerabilities. An attacker can exploit an open redirect vulnerability to use your website to give the appearance of a legitimate URL, but redirect an unsuspecting visitor to a phishing or other malicious webpage.|
|[CA3008: Review code for XPath injection vulnerabilities](../code-quality/ca3008.md)|When working with untrusted input, be mindful of XPath injection attacks. Constructing XPath queries using untrusted input may allow an attacker to maliciously manipulate the query to return an unintended result, and possibly disclose the contents of the queried XML.|
|[CA3009: Review code for XML injection vulnerabilities](../code-quality/ca3009.md)|When working with untrusted input, be mindful of XML injection attacks.|
|[CA3010: Review code for XAML injection vulnerabilities](../code-quality/ca3010.md)|When working with untrusted input, be mindful of XAML injection attacks. XAML is a markup language that directly represents object instantiation and execution. That means elements created in XAML can interact with system resources (for example, network access and file system IO).|
|[CA3011: Review code for DLL injection vulnerabilities](../code-quality/ca3011.md)|When working with untrusted input, be mindful of loading untrusted code. If your web application loads untrusted code, an attacker may be able to inject malicious DLLs into your process and execute malicious code.|
|[CA3012: Review code for regex injection vulnerabilities](../code-quality/ca3012.md)|When working with untrusted input, be mindful of regex injection attacks. An attacker can use regex injection to maliciously modify a regular expression, to make the regex match unintended results, or to make the regex consume excessive CPU resulting in a Denial of Service attack.|
|[CA3061: Do not add schema by URL](../code-quality/ca3061.md)|Do not use the unsafe overload of the Add method because it may cause dangerous external references.|
|[CA3075: Insecure DTD Processing](../code-quality/ca3075.md)|If you use insecure DTDProcessing instances or reference external entity sources, the parser may accept untrusted input and disclose sensitive information to attackers.|
|[CA3076: Insecure XSLT Script Execution](../code-quality/ca3076.md)|If you execute Extensible Stylesheet Language Transformations (XSLT) in .NET applications insecurely, the processor may resolve untrusted URI references that could disclose sensitive information to attackers, leading to Denial of Service and Cross-Site attacks.|
|[CA3077: Insecure Processing in API Design, XML Document and XML Text Reader](../code-quality/ca3077.md)|When designing an API derived from XMLDocument and XMLTextReader, be mindful of DtdProcessing. Using insecure DTDProcessing instances when referencing or resolving external entity sources or setting insecure values in the XML may lead to information disclosure.|
|[CA3147: Mark verb handlers with ValidateAntiForgeryToken](../code-quality/ca3147.md)|When designing an ASP.NET MVC controller, be mindful of cross-site request forgery attacks. A cross-site request forgery attack can send malicious requests from an authenticated user to your ASP.NET MVC controller.|
|[CA5122 P/Invoke declarations should not be safe critical](../code-quality/ca5122.md)|Methods are marked as SecuritySafeCritical when they perform a security sensitive operation, but are also safe to be used by transparent code. Transparent code may never directly call native code through a P/Invoke. Therefore, marking a P/Invoke as security safe critical will not enable transparent code to call it, and is misleading for security analysis.|
|[CA5359: Do not disable certificate validation](../code-quality/ca5359.md)|A certificate can help authenticate the identity of the server. Clients should validate the server certificate to ensure requests are sent to the intended server. If the ServerCertificateValidationCallback always returns `true`, any certificate will pass validation.|
|[CA5361: Do not disable SChannel use of strong crypto](../code-quality/ca5361.md)|Setting `Switch.System.Net.DontEnableSchUseStrongCrypto` to `true` weakens the cryptography used in outgoing Transport Layer Security (TLS) connections. Weaker cryptography can compromise the confidentiality of communication between your application and the server, making it easier for attackers to eavesdrop sensitive data.|
|[CA5362: Potential reference cycle in deserialized object graph](../code-quality/ca5362.md)|If deserializing untrusted data, then any code processing the deserialized object graph needs to handle reference cycles without going into infinite loops. This includes both code that's part of a deserialization callback and code that processes the object graph after deserialization completed. Otherwise, an attacker could perform a Denial-of-Service attack with malicious data containing a reference cycle.|
|[CA5363: Do not disable request validation](../code-quality/ca5363.md)|Request validation is a feature in ASP.NET that examines HTTP requests and determines whether they contain potentially dangerous content that can lead to injection attacks, including cross-site-scripting.|
|[CA5364: Do not use deprecated security protocols](../code-quality/ca5364.md)|Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS). Older protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities. Avoid older protocol versions to minimize risk.|
|[CA5365: Do Not Disable HTTP Header Checking](../code-quality/ca5365.md)|HTTP header checking enables encoding of the carriage return and newline characters, \r and \n, that are found in response headers. This encoding can help to avoid injection attacks that exploit an application that echoes untrusted data contained by the header.|
|[CA5366: Use XmlReader For DataSet Read XML](../code-quality/ca5366.md)|Using a <xref:System.Data.DataSet> to read XML with untrusted data may load dangerous external references, which should be restricted by using an <xref:System.Xml.XmlReader> with a secure resolver or with DTD processing disabled.|
|[CA5367: Do Not Serialize Types With Pointer Fields](../code-quality/ca5367.md)|This rule checks whether there’s a serializable class with a pointer field or property. Members that can’t be serialized can be a pointer, such as static members or fields marked with <xref:System.NonSerializedAttribute>.|
|[CA5368: Set ViewStateUserKey For Classes Derived From Page](../code-quality/ca5368.md)|Setting the <xref:System.Web.UI.Page.ViewStateUserKey> property can help you prevent attacks on your application by allowing you to assign an identifier to the view-state variable for individual users so that attackers cannot use the variable to generate an attack. Otherwise, there will be vulnerabilities to cross-site request forgery.|
|[CA5369: Use XmlReader for Deserialize](../code-quality/ca5369.md)|Processing untrusted DTD and XML schemas may enable loading dangerous external references, which should be restricted by using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.|
|[CA5370: Use XmlReader for validating reader](../code-quality/ca5370.md)|Processing untrusted DTD and XML schemas may enable loading dangerous external references. This dangerous loading can be restricted by using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled.|
|[CA5371: Use XmlReader for schema read](../code-quality/ca5371.md)|Processing untrusted DTD and XML schemas may enable loading dangerous external references. Using an XmlReader with a secure resolver or with DTD and XML inline schema processing disabled restricts this.|
|[CA5372: Use XmlReader for XPathDocument](../code-quality/ca5372.md)|Processing XML from untrusted data may load dangerous external references, which can be restricted by using an XmlReader with a secure resolver or with DTD processing disabled.|
|[CA5373: Do not use obsolete key derivation function](../code-quality/ca5373.md)|This rule detects the invocation of weak key derivation methods <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> and `Rfc2898DeriveBytes.CryptDeriveKey`. <xref:System.Security.Cryptography.PasswordDeriveBytes?displayProperty=fullName> used a weak algorithm PBKDF1.|
|[CA5374: Do Not Use XslTransform](../code-quality/ca5374.md)|This rule checks if <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> is instantiated in the code. <xref:System.Xml.Xsl.XslTransform?displayProperty=nameWithType> is now obsolete and shouldn’t be used.|
|[CA5378: Do not disable ServicePointManagerSecurityProtocols](../code-quality/ca5378.md)|Setting `Switch.System.ServiceModel.DisableUsingServicePointManagerSecurityProtocols` to `true` limits Windows Communication Framework's (WCF) Transport Layer Security (TLS) connections to using TLS 1.0. That version of TLS will be deprecated.|
|[CA5379: Do not use weak key derivation function algorithm](../code-quality/ca5379.md)|The <xref:System.Security.Cryptography.Rfc2898DeriveBytes> class defaults to using the <xref:System.Security.Cryptography.HashAlgorithmName.SHA1> algorithm. You should specify the hash algorithm to use in some overloads of the constructor with <xref:System.Security.Cryptography.HashAlgorithmName.SHA256> or higher. Note, <xref:System.Security.Cryptography.Rfc2898DeriveBytes.HashAlgorithm> property only has a `get` accessor and doesn't have a `overriden` modifier.|
|[CA5380: Do not add certificates to root store](../code-quality/ca5380.md)|This rule detects code that adds a certificate into the Trusted Root Certification Authorities certificate store. By default, the Trusted Root Certification Authorities certificate store is configured with a set of public CAs that has met the requirements of the Microsoft Root Certificate Program.|
|[CA5381: Ensure certificates are not added to root store](../code-quality/ca5381.md)|This rule detects code that potentially adds a certificate into the Trusted Root Certification Authorities certificate store. By default, the Trusted Root Certification Authorities certificate store is configured with a set of public certification authorities (CAs) that has met the requirements of the Microsoft Root Certificate Program.|
|[CA5382: Use secure cookies in ASP.NET Core](../code-quality/ca5382.md)|Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using Transport Layer Security (TLS).|
|[CA5383: Ensure use secure cookies in ASP.NET Core](../code-quality/ca5383.md)|Applications available over HTTPS must use secure cookies, which indicate to the browser that the cookie should only be transmitted using Transport Layer Security (TLS).|
|[CA5384: Do not use digital signature algorithm (DSA)](../code-quality/ca5384.md)|DSA is a weak asymmetric encryption algorithm.|
|[CA5385: Use Rivest–Shamir–Adleman (RSA) algorithm with sufficient key size](../code-quality/ca5385.md)|An RSA key smaller than 2048 bits is more vulnerable to brute force attacks.|
|[CA5386: Avoid hardcoding SecurityProtocolType value](../code-quality/ca5386.md)|Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS). Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current. In the future, TLS 1.2 and TLS 1.3 may be deprecated. To ensure that your application remains secure, avoid hardcoding a protocol version and target at least .NET Framework v4.7.1.|
|[CA5387: Do not use weak key derivation function with insufficient iteration count](../code-quality/ca5387.md)|This rule checks if a cryptographic key was generated by <xref:System.Security.Cryptography.Rfc2898DeriveBytes> with an iteration count of less than 100,000. A higher iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.|
|[CA5388: Ensure sufficient iteration count when using weak key derivation function](../code-quality/ca5388.md)|This rule checks if a cryptographic key was generated by <xref:System.Security.Cryptography.Rfc2898DeriveBytes> with an iteration count that may be less than 100,000. A higher iteration count can help mitigate against dictionary attacks that try to guess the generated cryptographic key.|
|[CA5389: Do not add archive item's path to the target file system path](../code-quality/ca5389.md)|File path can be relative and can lead to file system access outside of the expected file system target path, leading to malicious config changes and remote code execution via lay-and-wait technique.|
|[CA5390: Do not hard-code encryption key](../code-quality/ca5390.md)|For a symmetric algorithm to be successful, the secret key must be known only to the sender and the receiver. When a key is hard-coded, it is easily discovered. Even with compiled binaries, it is easy for malicious users to extract it. Once the private key is compromised, the cipher text can be decrypted directly and is not protected anymore.|
|[CA5394: Do not use insecure randomness](../code-quality/ca5394.md)|Using a cryptographically weak pseudo-random number generator may allow an attacker to predict what security-sensitive value will be generated.|
|[CA5396: Set HttpOnly to true for HttpCookie](../code-quality/ca5396.md)|As a defense in depth measure, ensure security sensitive HTTP cookies are marked as HttpOnly. This indicates web browsers should disallow scripts from accessing the cookies. Injected malicious scripts are a common way of stealing cookies.|
|[CA5397: Do not use deprecated SslProtocols values](../code-quality/ca5397.md)|Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS). Older protocol versions of TLS are less secure than TLS 1.2 and TLS 1.3 and are more likely to have new vulnerabilities. Avoid older protocol versions to minimize risk.|
|[CA5398: Avoid hardcoded SslProtocols values](../code-quality/ca5398.md)|Transport Layer Security (TLS) secures communication between computers, most commonly with Hypertext Transfer Protocol Secure (HTTPS). Protocol versions TLS 1.0 and TLS 1.1 are deprecated, while TLS 1.2 and TLS 1.3 are current. In the future, TLS 1.2 and TLS 1.3 may be deprecated. To ensure that your application remains secure, avoid hardcoding a protocol version.|
|[CA5401: Do not use CreateEncryptor with non-default IV](../code-quality/ca5401.md)|Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.|
|[CA5402: Use CreateEncryptor with the default IV](../code-quality/ca5402.md)|Symmetric encryption should always use a non-repeatable initialization vector to prevent dictionary attacks.|
